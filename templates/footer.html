<!-- {% load static %} -->

<script>
  (function () {
    const chatHistory = document.getElementById("chatHistory");
    const messageInput = document.getElementById("messageInput");
    const sendBtn = document.getElementById("sendBtn");
    const typingIndicator = document.getElementById("typingIndicator");
    const errorBanner = document.getElementById("errorBanner");
    const quickReplies = document.getElementById("quickReplies");
    const darkToggle = document.getElementById("darkToggle");
    const micBtn = document.getElementById("micBtn");
    const fileUploadBtn = document.getElementById("fileUploadBtn");
    const uploadModal = document.getElementById("uploadModal");
    const closeUploadModal = document.getElementById("closeUploadModal");
    const cancelUpload = document.getElementById("cancelUpload");
    const dropZone = document.getElementById("dropZone");
    const fileInput = document.getElementById("fileInput");
    const processDocument = document.getElementById("processDocument");
    const uploadProgress = document.getElementById("uploadProgress");
    const progressBar = document.getElementById("progressBar");
    const progressPercent = document.getElementById("progressPercent");
    const API_URL = "/api/chat/";

    let isDark = false;
    const preferredDark = localStorage.getItem("chat-dark");
    if (preferredDark === "1") {
      document.documentElement.classList.add("dark");
      isDark = true;
    }

    let documentData = null;
    let extractedFields = {};

    function scrollToBottom() {
      chatHistory.scrollTo({
        top: chatHistory.scrollHeight,
        behavior: "smooth",
      });
    }

    function createMessageEl({ text, who = "bot", timestamp = Date.now(), html = null }) {
      const wrapper = document.createElement("div");
      wrapper.className = "flex " + (who === "user" ? "justify-end" : "justify-start") + " px-1";
      
      const bubble = document.createElement("div");
      bubble.className = [
        "max-w-[85%] break-words text-sm px-4 py-3 rounded-2xl shadow-sm",
        "animate-fade-in-up",
      ].join(" ");

      if (who === "user") {
        bubble.classList.add("bg-indigo-600", "text-white", "rounded-br-none");
      } else {
        bubble.classList.add("bg-gray-100", "dark:bg-gray-700", "text-gray-900", "dark:text-gray-100", "rounded-bl-none");
      }

      if (html) {
        bubble.innerHTML = html;
      } else {
        bubble.innerText = text;
      }

      wrapper.appendChild(bubble);
      return wrapper;
    }

    function createExtractionForm(fields) {
      let html = `
        <div class="mb-3">
          <h3 class="font-semibold text-base mb-2">Extracted Document Information</h3>
          <p class="text-sm text-gray-600 dark:text-gray-400 mb-3">Review and edit the extracted information below:</p>
        </div>
        <div class="space-y-3">
      `;

      Object.entries(fields).forEach(([field, value]) => {
        html += `
          <div class="field-row flex items-center gap-2 p-2 rounded-md">
            <label class="w-1/3 text-sm font-medium text-gray-700 dark:text-gray-300">${field.replace(/_/g, ' ').toUpperCase()}:</label>
            <input type="text" 
                   class="flex-1 border border-gray-300 dark:border-gray-600 rounded px-3 py-1.5 text-sm bg-white dark:bg-gray-800" 
                   value="${value}" 
                   data-field="${field}" />
          </div>
        `;
      });

      html += `
        </div>
        <div class="mt-4 flex justify-end gap-2">
          <button id="cancelEdit" class="px-3 py-1.5 text-sm font-medium text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-lg transition">
            Cancel
          </button>
          <button id="saveDocumentData" class="px-3 py-1.5 text-sm font-medium bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition">
            Save Data
          </button>
        </div>
      `;

      return html;
    }

    function showTyping(show = true) {
      typingIndicator.classList.toggle("hidden", !show);
      scrollToBottom();
    }

    function showError(msg) {
      errorBanner.innerText = msg;
      errorBanner.classList.remove("hidden");
      setTimeout(() => errorBanner.classList.add("hidden"), 6000);
    }

    function updateProgress(percent) {
      progressBar.style.width = `${percent}%`;
      progressPercent.textContent = `${percent}%`;
    }

    function fileToBase64(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = () => {
          const base64 = reader.result.split(',')[1];
          resolve(base64);
        };
        reader.onerror = error => reject(error);
      });
    }

    async function extractTextFromImage(base64Image, fileType) {
      try {
        const apiResponse = await fetch(API_URL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            fileBase64: base64Image,
            fileType: fileType
          })
        });

        if (!apiResponse.ok) {
          throw new Error(`Backend API error: ${apiResponse.status}`);
        }

        const data = await apiResponse.json();
        return data.text || "No text extracted.";

      } catch (err) {
        console.error("Document processing error:", err);
        throw new Error("Failed to extract text from document");
      }
    }

    async function sendMessage(text, opts = {}) {
      const trimmed = String(text || "").trim();
      if (!trimmed) return;

      const userMsg = createMessageEl({ text: trimmed, who: "user" });
      chatHistory.appendChild(userMsg);
      scrollToBottom();

      messageInput.value = "";
      messageInput.focus();

      showTyping(true);

      try {
        let response;
        const apiResponse = await fetch(API_URL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            message: trimmed,
            documentData: documentData || null
          })
        });

        if (!apiResponse.ok) {
          throw new Error(`Backend API error: ${apiResponse.status}`);
        }

        const data = await apiResponse.json();
        response = data.response || data.text || "No response from server.";

        const botMsg = createMessageEl({ text: response, who: "bot" });
        chatHistory.appendChild(botMsg);

      } catch (err) {
        console.error("Chat API error:", err);
        const botMsg = createMessageEl({ text: "Error: " + err.message, who: "bot" });
        chatHistory.appendChild(botMsg);
      } finally {
        showTyping(false);
        scrollToBottom();
      }
    }

    async function processUploadedDocument(file) {
      uploadProgress.classList.remove("hidden");
      updateProgress(10);

      try {
        updateProgress(30);
        
        const base64Data = await fileToBase64(file);
        
        updateProgress(60);
        
        const extractedText = await extractTextFromImage(base64Data, file.type);
        
        updateProgress(80);
        
        extractedFields = parseExtractedText(extractedText);
        
        updateProgress(100);

        const formHtml = createExtractionForm(extractedFields);
        const botMsg = createMessageEl({ 
          html: formHtml, 
          who: "bot" 
        });
        
        chatHistory.appendChild(botMsg);
        scrollToBottom();
        
        document.getElementById('saveDocumentData').addEventListener('click', saveDocumentData);
        document.getElementById('cancelEdit').addEventListener('click', () => {
          chatHistory.removeChild(botMsg);
        });

      } catch (err) {
        showError(err.message || "Failed to process the document.");
        const botMsg = createMessageEl({
          text: "Sorry, I couldn't extract information from that document. Please try another file.",
          who: "bot",
        });
        chatHistory.appendChild(botMsg);
      } finally {
        setTimeout(() => {
          uploadProgress.classList.add("hidden");
          updateProgress(0);
        }, 1000);
        
        closeUploadModal.click();
      }
    }

    function saveDocumentData() {
      const inputs = document.querySelectorAll('input[data-field]');
      inputs.forEach(input => {
        const field = input.getAttribute('data-field');
        extractedFields[field] = input.value;
      });
      
      documentData = extractedFields;
      
      const botMsg = createMessageEl({
        text: "Document data saved successfully! You can now ask questions about your document.",
        who: "bot",
      });
      chatHistory.appendChild(botMsg);
      scrollToBottom();
    }

    sendBtn.addEventListener("click", () => sendMessage(messageInput.value));

    messageInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        sendMessage(messageInput.value);
      }
    });

    quickReplies.addEventListener("click", (e) => {
      const btn = e.target.closest("button");
      if (!btn) return;
      
      const text = btn.innerText;
      if (text === "Upload document") {
        fileUploadBtn.click();
      } else if (text === "Show extracted data" && documentData) {
        const fieldsText = Object.entries(documentData)
          .map(([key, value]) => `${key.replace(/_/g, ' ').toUpperCase()}: ${value}`)
          .join('\n');
        sendMessage(`Here's the extracted data from my document:\n${fieldsText}`);
      } else {
        sendMessage(text);
      }
    });

    darkToggle.addEventListener("click", () => {
      isDark = !isDark;
      if (isDark) {
        document.documentElement.classList.add("dark");
        localStorage.setItem("chat-dark", "1");
      } else {
        document.documentElement.classList.remove("dark");
        localStorage.setItem("chat-dark", "0");
      }
    });

    fileUploadBtn.addEventListener("click", () => {
      uploadModal.classList.remove("hidden");
    });

    [closeUploadModal, cancelUpload].forEach(btn => {
      btn.addEventListener("click", () => {
        uploadModal.classList.add("hidden");
        fileInput.value = "";
        processDocument.disabled = true;
        uploadProgress.classList.add("hidden");
        updateProgress(0);
      });
    });

    dropZone.addEventListener("click", () => {
      fileInput.click();
    });

    dropZone.addEventListener("dragover", (e) => {
      e.preventDefault();
      dropZone.classList.add("border-indigo-400", "bg-indigo-50", "dark:bg-indigo-900/20");
    });

    dropZone.addEventListener("dragleave", () => {
      dropZone.classList.remove("border-indigo-400", "bg-indigo-50", "dark:bg-indigo-900/20");
    });

    dropZone.addEventListener("drop", (e) => {
      e.preventDefault();
      dropZone.classList.remove("border-indigo-400", "bg-indigo-50", "dark:bg-indigo-900/20");
      
      if (e.dataTransfer.files.length) {
        fileInput.files = e.dataTransfer.files;
        processDocument.disabled = false;
      }
    });

    fileInput.addEventListener("change", () => {
      processDocument.disabled = !fileInput.files.length;
    });

    processDocument.addEventListener("click", () => {
      if (fileInput.files.length) {
        processUploadedDocument(fileInput.files[0]);
      }
    });

    let recognition = null;
    let listening = false;
    if ("webkitSpeechRecognition" in window || "SpeechRecognition" in window) {
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      recognition = new SpeechRecognition();
      recognition.lang = "en-IN";
      recognition.interimResults = false;
      recognition.maxAlternatives = 1;

      recognition.addEventListener("result", (ev) => {
        const transcript = Array.from(ev.results)
          .map((r) => r[0])
          .map((x) => x.transcript)
          .join("");
        messageInput.value = transcript;
      });

      recognition.addEventListener("end", () => {
        listening = false;
        micBtn.classList.remove("bg-red-100", "dark:bg-red-900/50");
      });
    } else {
      micBtn.title = "Speech recognition not supported in this browser";
      micBtn.classList.add("opacity-40", "cursor-not-allowed");
    }

    micBtn.addEventListener("click", () => {
      if (!recognition) return;
      if (!listening) {
        try {
          recognition.start();
          listening = true;
          micBtn.classList.add("bg-red-100", "dark:bg-red-900/50");
        } catch (e) {
          console.warn(e);
        }
      } else {
        recognition.stop();
        listening = false;
        micBtn.classList.remove("bg-red-100", "dark:bg-red-900/50");
      }
    });

    chatHistory.addEventListener("click", () => messageInput.focus());

    function initWelcome() {
      const botIntro = createMessageEl({
        text: "Hi! I'm ASK_ME, your document intelligence assistant. Upload documents like Aadhar cards, invoices, or forms, and I'll extract the information for you to review. Then you can ask me questions about your documents!",
        who: "bot",
      });
      chatHistory.appendChild(botIntro);
      scrollToBottom();
    }
    initWelcome();

    function autoResizeTA(el) {
      el.style.height = "auto";
      el.style.height = el.scrollHeight + "px";
    }
    messageInput.addEventListener("input", () => autoResizeTA(messageInput));
    autoResizeTA(messageInput);
    function adaptQuickReplies() {
      if (window.innerWidth < 420) quickReplies.classList.add("hidden");
      else quickReplies.classList.remove("hidden");
    }
    window.addEventListener("resize", adaptQuickReplies);
    adaptQuickReplies();
  })();
</script>
</body>
</html>